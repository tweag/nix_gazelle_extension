package gazelle

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/tweag/nix_gazelle_extension/nix/gazelle/nixconfig"
)

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// empty is a list of empty rules that may be deleted after merge.
//
// gen is a list of generated rules that may be updated or added.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (nixLang *nixLang) GenerateRules(
	args language.GenerateArgs,
) language.GenerateResult {
	logger := nixLang.logger.With().
		Str("step", "gazelle.nixLang.GenerateRules").
		Str("path", args.Rel).
		Str("language", languageName).
		Logger()

	logger.Debug().Msg("")
	nixConfigs, ok := args.Config.Exts[languageName].(nixconfig.Configs)

	if !ok {
		logger.Fatal().
			Err(errAssert).
			Msgf("Cannot extract configs")
	}
	cfg, ok := nixConfigs[args.Rel]

	if !ok {
		logger.Fatal().
			Err(errAssert).
			Msgf("Cannot extract config")
	}

	nixPreludeConf := cfg.NixPrelude()
	nixRepositoriesConf := cfg.NixRepositories()

	var res language.GenerateResult

	for _, sourceFile := range append(args.RegularFiles, args.GenFiles...) {
		logger.Trace().
			Str("source", sourceFile).
			Msg("considering")

		if sourceFile != "default.nix" {
			continue
		}

		logger.Info().
			Str("file", sourceFile).
			Msg("parsing nix file")

		pth := filepath.Join(args.Dir, sourceFile)

		//TODO: parser should be launched only when generating
		//workspace rules
		nixFileDep, err := nixToDepSets(&logger, nixPreludeConf, pth)
		if err != nil {
			continue
		}

		pkgName := strings.ReplaceAll(args.Rel, "/", ".")

		// TODO: instead of using template file
		// use already existing/generated one.
		bzlTemplate := strings.ReplaceAll(
			sourceFile,
			"default.nix",
			"BUILD.bazel.tpl",
		)

		var buildFile string
		buildFile = fmt.Sprintf("//%s:BUILD.bazel.tpl", args.Rel)

		nra := &NixRuleArgs{
			attrs: map[string]interface{}{
				"name": pkgName,
			},
			comments: []string{
				"# autogenerated",
			},
		}
		if cfg.WsMode() {
			nra.kind = packageRule
			nra.attrs["nix_file_deps"] = nixFileDep.DepSets[0].Files
			nra.attrs["repositories"] = nixRepositoriesConf

			if len(nixPreludeConf) > 0 {
				nra.attrs["nix_file"] = fmt.Sprintf("//:%s", nixPreludeConf)
				nra.attrs["nix_opts"] = []string{
					"--argstr",
					"nix_file",
					filepath.Join(args.Rel, sourceFile),
				}
			} else {
				nra.attrs["nix_file"] = fmt.Sprintf("//%s:%s", args.Rel, sourceFile)
			}

			if fileExists(bzlTemplate) {
				nra.attrs["build_file"] = buildFile
			}

		} else {
			if fileExists(bzlTemplate) {
				nixFileDep.DepSets[1].Files = append(
					nixFileDep.DepSets[1].Files,
					buildFile,
				)
			}
			nra.kind = exportRule
			nra.attrs["files"] = nixFileDep.DepSets[1].Files
		}
		res.Gen = append(res.Gen, genNixRule(nra))
	}

	res.Imports = make([]interface{}, len(res.Gen))
	for i, r := range res.Gen {
		res.Imports[i] = r.PrivateAttr(config.GazelleImportsKey)
	}

	return res
}

func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}

	return !info.IsDir()
}
