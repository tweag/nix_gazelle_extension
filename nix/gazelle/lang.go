package gazelle

import (
	"errors"
	"os"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/rs/zerolog"
	"github.com/tweag/nix_gazelle_extension/nix/gazelle/private/logconfig"
)

var (
	errAssert = errors.New("assertion failed")
	errParse  = errors.New("directive parsing failed")
)

type nixLang struct {
	config.Configurer
	resolve.Resolver

	logger zerolog.Logger
}

// NewLanguage implementation.
func NewLanguage() language.Language {

	logLevel := logconfig.LogLevel()
	logger := zerolog.New(zerolog.ConsoleWriter{Out: os.Stderr}).
		With().
		Timestamp().
		Caller().
		Logger().
		Level(logLevel)
	logger.Debug().Msg("creating nix language")

	nl := nixLang{
		logger: logger,
	}
	nl.Configurer = NewConfigurer(&nl)
	nl.Resolver = NewResolver(&nl)

	return &nl
}

//func (l *nixLang) Name() string { return nixName }

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
func (l *nixLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		exportRule: {
			MatchAny:   false,
			MatchAttrs: []string{"name"},
		},
		packageRule: {
			MatchAttrs: []string{"name", "nix_file_deps"},
			MergeableAttrs: map[string]bool{
				"nix_file_deps": true,
			},
		},
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (l *nixLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name: "@io_tweag_gazelle_nix//nix:defs.bzl",
			Symbols: []string{
				exportRule,
			},
		},
		{
			Name: "@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl",
			Symbols: []string{
				packageRule,
			},
		},
	}
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (l *nixLang) Fix(c *config.Config, buildFile *rule.File) {
	for _, loadStatement := range buildFile.Loads {
		if loadStatement.Has(exportRule) {
			loadStatement.Remove(exportRule)

			if loadStatement.IsEmpty() {
				loadStatement.Delete()
			}
		}
	}

	var knownRuleStatements []*rule.Rule

	for _, ruleStatement := range buildFile.Rules {
		if ruleStatement.Kind() == exportRule {
			knownRuleStatements = append(knownRuleStatements, ruleStatement)
		}
	}

	for _, knownRuleStatement := range knownRuleStatements {
		knownRuleStatement.Delete()
	}
}
