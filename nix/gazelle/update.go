package gazelle

import (
	"flag"
	"fmt"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	golang "github.com/bazelbuild/bazel-gazelle/language/go"
	"github.com/bazelbuild/bazel-gazelle/language/proto"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/bazel-gazelle/walk"
	"github.com/rs/zerolog"
	"github.com/tweag/nix_gazelle_extension/nix/gazelle/nixconfig"
)

type nixWorkspaceLibrary struct {
	Name         string
	NixFile      string
	BuildFile    string
	NixFileDeps  []string
	Repositories map[string]string
	NixOpts      []string
}

func (nixLang *nixLang) UpdateRepos(
	args language.UpdateReposArgs,
) language.UpdateReposResult {
	logger := nixLang.logger.With().
		Str("step", "gazelle.nixLang.UpdateRepos").
		Str("path", args.Config.WorkDir).
		Str("language", languageName).
		Logger()

	logger.Debug().Msg("")

	packageList := collectDependenciesFromRepo(&logger, args.Config, nixLang)
	nixConfig, ok := args.Config.Exts[languageName].(nixconfig.Configs)

	if !ok {
		return language.UpdateReposResult{
			Error: fmt.Errorf("%w %s", errAssert, "nixConfig"),
			Gen:   nil,
		}
	}

	// TODO: extract repositories from a specific buildfile, not a
	// top-level one
	cfg, ok := nixConfig[""]
	if !ok {
		return language.UpdateReposResult{
			Error: fmt.Errorf("%w %s", errAssert, "nixConfig"),
			Gen:   nil,
		}
	}

	nixRepositoriesConf := cfg.NixRepositories()

	repoRuleStatements := make([]*rule.Rule, len(packageList))

	for idx, pkg := range packageList {
		ruleStatement := rule.NewRule(packageRule, pkg.Name)
		ruleStatement.SetAttr("nix_file", pkg.NixFile)
		ruleStatement.SetAttr("nixopts", pkg.NixOpts)
		ruleStatement.SetAttr("nix_file_deps", pkg.NixFileDeps)
		ruleStatement.SetAttr("repositories", nixRepositoriesConf)

		if len(pkg.BuildFile) > 0 {
			ruleStatement.SetAttr("build_file", pkg.BuildFile)
		}

		ruleStatement.AddComment("# autogenerated")
		repoRuleStatements[idx] = ruleStatement
	}

	return language.UpdateReposResult{
		Error: nil,
		Gen:   repoRuleStatements,
	}
}

func collectDependenciesFromRepo(
	logger *zerolog.Logger,
	extensionConfig *config.Config,
	lang language.Language,
) []nixWorkspaceLibrary {
	packages := make([]nixWorkspaceLibrary, 0)
	cexts := []config.Configurer{
		&config.CommonConfigurer{},
		&walk.Configurer{},
		lang,
		golang.NewLanguage(),
		proto.NewLanguage(),
	}

	initUpdateReposConfig(logger, extensionConfig, cexts)

	walk.Walk(
		extensionConfig,
		cexts,
		[]string{},
		walk.VisitAllUpdateDirsMode,
		func(
			_,
			_ string,
			_ *config.Config,
			_ bool,
			buildFile *rule.File,
			_,
			_,
			_ []string,
		) {
			collectDependenciesFromFile(buildFile, &packages)
		},
	)

	return packages
}

func initUpdateReposConfig(logger *zerolog.Logger, extensionConfig *config.Config, cexts []config.Configurer) {
	flagSet := flag.NewFlagSet("updateReposFlagSet", flag.ContinueOnError)

	for _, cext := range cexts {
		cext.RegisterFlags(flagSet, "update", extensionConfig)
	}

	for _, cext := range cexts {
		if err := cext.CheckFlags(flagSet, extensionConfig); err != nil {
			logger.Fatal().
				Err(err).
				Msg("")
		}
	}
}

func collectDependenciesFromFile(
	buildFile *rule.File,
	packages *[]nixWorkspaceLibrary,
) {

	if buildFile != nil {
		for _, ruleStatement := range buildFile.Rules {
			if ruleStatement.Kind() == exportRule {
				pkg := nixWorkspaceLibrary{
					Name:         ruleStatement.AttrString("name"),
					NixFile:      ruleStatement.AttrString("nix_file"),
					NixFileDeps:  ruleStatement.AttrStrings("deps"),
					NixOpts:      ruleStatement.AttrStrings("nixopts"),
					BuildFile:    ruleStatement.AttrString("build_file"),
					Repositories: make(map[string]string),
				}
				*packages = append(*packages, pkg)
			}
		}
	}
}
