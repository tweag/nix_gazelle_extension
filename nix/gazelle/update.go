package gazelle

import (
	"flag"
	"fmt"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	golang "github.com/bazelbuild/bazel-gazelle/language/go"
	"github.com/bazelbuild/bazel-gazelle/language/proto"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/bazel-gazelle/walk"
	"github.com/rs/zerolog"
	"github.com/tweag/nix_gazelle_extension/nix/gazelle/nixconfig"
)

func (nixLang *nixLang) UpdateRepos(
	args language.UpdateReposArgs,
) language.UpdateReposResult {
	logger := nixLang.logger.With().
		Str("step", "gazelle.nixLang.UpdateRepos").
		Str("path", args.Config.WorkDir).
		Str("language", languageName).
		Logger()

	logger.Debug().Msg("")

	packageList := collectDependenciesFromRepo(&logger, args.Config, nixLang)
	nixConfigs, ok := args.Config.Exts[languageName].(nixconfig.Configs)

	if !ok {
		return language.UpdateReposResult{
			Error: fmt.Errorf("%w %s", errAssert, "nixConfig"),
			Gen:   nil,
		}
	}

	repoRuleStatements := make([]*rule.Rule, len(packageList))

	for idx, pkg := range packageList {
		cfg, ok := nixConfigs[pkg.rel]
		if !ok {
			return language.UpdateReposResult{
				Error: fmt.Errorf("%w %s", errAssert, "nixConfig"),
				Gen:   nil,
			}
		}
		nixRepositoriesConf := cfg.NixRepositories()

		ruleStatement := rule.NewRule(packageRule, pkg.name)
		ruleStatement.SetAttr("nix_file", pkg.nixFile)
		ruleStatement.SetAttr("nixopts", pkg.nixOpts)
		ruleStatement.SetAttr("nix_file_deps", pkg.nixFileDeps)
		ruleStatement.SetAttr("repositories", nixRepositoriesConf)

		if len(pkg.buildFile) > 0 {
			ruleStatement.SetAttr("build_file", pkg.buildFile)
		}

		ruleStatement.AddComment("# autogenerated")
		repoRuleStatements[idx] = ruleStatement
	}

	sortRules(repoRuleStatements)
	return language.UpdateReposResult{
		Error: nil,
		Gen:   repoRuleStatements,
	}
}

func sortRules(rules []*rule.Rule) {
	sort.SliceStable(rules, func(i, j int) bool {
		if cmp := strings.Compare(rules[i].Name(), rules[j].Name()); cmp != 0 {
			return cmp < 0
		}
		return rules[i].AttrString("name") < rules[j].AttrString("name")
	})
}

func collectDependenciesFromRepo(
	logger *zerolog.Logger,
	extensionConfig *config.Config,
	lang language.Language,
) []nixPackage {
	packages := make([]nixPackage, 0)
	cexts := []config.Configurer{
		&config.CommonConfigurer{},
		&walk.Configurer{},
		lang,
		golang.NewLanguage(),
		proto.NewLanguage(),
	}

	initUpdateReposConfig(logger, extensionConfig, cexts)

	walk.Walk(
		extensionConfig,
		cexts,
		[]string{},
		walk.VisitAllUpdateDirsMode,
		func(
			_,
			rel string,
			_ *config.Config,
			_ bool,
			buildFile *rule.File,
			_,
			_,
			_ []string,
		) {
			collectDependenciesFromFile(buildFile, rel, &packages)
		},
	)

	return packages
}

func initUpdateReposConfig(logger *zerolog.Logger, extensionConfig *config.Config, cexts []config.Configurer) {
	flagSet := flag.NewFlagSet("updateReposFlagSet", flag.ContinueOnError)

	for _, cext := range cexts {
		cext.RegisterFlags(flagSet, "update", extensionConfig)
	}

	for _, cext := range cexts {
		if err := cext.CheckFlags(flagSet, extensionConfig); err != nil {
			logger.Fatal().
				Err(err).
				Msg("")
		}
	}
}

func collectDependenciesFromFile(
	buildFile *rule.File,
	rel string,
	packages *[]nixPackage,
) {
	// Translate to repository rules.
	if buildFile != nil {
		for _, ruleStatement := range buildFile.Rules {
			if ruleStatement.Kind() == exportRule {
				pkg := nixPackage{
					name:         ruleStatement.AttrString("name"),
					nixFile:      ruleStatement.AttrString("nix_file"),
					nixFileDeps:  ruleStatement.AttrStrings("nix_file_deps"),
					nixOpts:      ruleStatement.AttrStrings("nixopts"),
					buildFile:    ruleStatement.AttrString("build_file"),
					rel:          rel,
					repositories: make(map[string]string),
				}
				*packages = append(*packages, pkg)
			}
		}
	}
}
