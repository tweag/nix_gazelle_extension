load(
    "@bazel_skylib//lib:shell.bzl",
    "shell",
)
load(
    "@bazel_gazelle//:def.bzl",
    "DEFAULT_LANGUAGES",
    "gazelle",
    "gazelle_binary",
)

def export_nix(name = "export_nix", files = []):
    """ This macro makes it possible for gazelle to store additional information. """
    native.exports_files(files)

def nixpkgs_package_manifest(**kwargs):
    pass

def _nix_gazelle_runner_impl(ctx):
    out_file = ctx.actions.declare_file(ctx.label.name + ".bash")
    substitutions = {
        "@@UPDATE_LABEL@@": shell.quote(str(ctx.attr.update_command.label)),
        "@@UPDATE_REPOS_LABEL@@": shell.quote(str(ctx.attr.update_repos_command.label)),
        "@@UPDATE_SHORT_PATH@@": shell.quote(ctx.executable.update_command.short_path),
        "@@UPDATE_REPOS_SHORT_PATH@@": shell.quote(ctx.executable.update_repos_command.short_path),
        "@@GENERATED_MESSAGE@@": """
# Generated by {label}
# DO NOT EDIT
""".format(label = str(ctx.label)),
        "@@RUNNER_LABEL@@": shell.quote(str(ctx.label)),
    }
    ctx.actions.expand_template(
        template = ctx.file._template,
        output = out_file,
        substitutions = substitutions,
        is_executable = True,
    )
    runfiles = ctx.runfiles(files = [
        ctx.executable.update_command,
        ctx.executable.update_repos_command,
    ]).merge(
        ctx.attr.update_command[DefaultInfo].default_runfiles,
    ).merge(
        ctx.attr.update_repos_command[DefaultInfo].default_runfiles,
    )
    return [DefaultInfo(
        files = depset([out_file]),
        runfiles = runfiles,
        executable = out_file,
    )]

_nix_gazelle_runner = rule(
    implementation = _nix_gazelle_runner_impl,
    attrs = {
        "update_command": attr.label(
            executable = True,
            cfg = "exec",
        ),
        "update_repos_command": attr.label(
            executable = True,
            cfg = "exec",
        ),
        "_template": attr.label(
            default = "@io_tweag_gazelle_nix//nix:nix_gazelle.bash.in",
            allow_single_file = True,
        ),
    },
    executable = True,
)

def nix_gazelle(name, **kwargs):
    runner_name = name + "-runner"
    gazelle_name = name + "-gazelle"
    binary_name = name + "-binary"
    update_name = name + "-update"
    update_repos_name = name + "-update-repos"
    update_all_name = name + "-update-all"

    gazelle(
        name = gazelle_name,
        gazelle = "//:" + binary_name,
    )

    gazelle_binary(
        name = binary_name,
        languages = DEFAULT_LANGUAGES + ["@io_tweag_gazelle_nix//nix/gazelle"],
    )

    gazelle(
        name = update_name,
        command = "update",
        extra_args = [
            "-lang",
            "nix",
        ],
        gazelle = "//:" + binary_name,
    )

    gazelle(
        name = update_repos_name,
        command = "update-repos",
        extra_args = [
            "-lang",
            "nix",
            "any",
        ],
        gazelle = "//:" + binary_name,
    )

    _nix_gazelle_runner(
        name = runner_name,
        update_command = "//:" + update_name,
        update_repos_command = "//:" + update_repos_name,
        tags = ["manual"],
        **kwargs
    )
    native.sh_binary(
        name = update_all_name,
        srcs = [runner_name],
        tags = ["manual"],
    )
