package gazelle_nix

import (
	"flag"
	"fmt"
	"go/build"
	"encoding/json"
	"log"
	"path"
	"path/filepath"
	"sort"
	"strings"

        "os"
        "os/exec"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/rules_go/go/tools/bazel"
)

const (
	nixName = "nix"
)

var _ = fmt.Printf

type nixLang struct{}

func NewLanguage() language.Language {
	return &nixLang{}
}

func (cl *nixLang) Name() string { return nixName }

type Lang struct {
	config.CommonConfigurer
	resolver
}

// Kinds returns a map of maps rule names (kinds) and information on how to
// match and merge attributes that may be found in rules of those kinds. All
// kinds of rules generated for this language may be found here.
func (l *nixLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"export": {
			MatchAny:   false,
			MatchAttrs: []string{"files"},
		},
	}
}

// Loads returns .bzl files and symbols they define. Every rule generated by
// GenerateRules, now or in the past, should be loadable from one of these
// files.
func (l *nixLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name: "//tools:exporter.bzl",
			Symbols: []string{
				"export",
			},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in depth-first post-order.
//
// args contains the arguments for GenerateRules. This is passed as a
// struct to avoid breaking implementations in the future when new
// fields are added.
//
// empty is a list of empty rules that may be deleted after merge.
//
// gen is a list of generated rules that may be updated or added.
//
// Any non-fatal errors this function encounters should be logged using
// log.Print.
func (l *nixLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	nixFiles := make(map[string]string)
	nixFilesDeps := make(map[string]*DepSets)
	for _, f := range append(args.RegularFiles, args.GenFiles...) {
		if !strings.HasSuffix(f, "default.nix") {
			continue
		}

		pth := filepath.Join(args.Dir, f)

		log.Printf("parsing nix file: path=%q", pth)
		nixFileDep, err := nixToDepSets(pth)
		if err != nil {
			log.Printf("failed parsing nix file: path=%q", pth)
			continue
		}

		nixFiles[f] = pth
		nixFilesDeps[f] = nixFileDep
	}

	//implicitPkgName := path.Base(args.Rel)

	libraries := make(map[string]*nixLibrary)

	for nixFile := range nixFiles {
		fileDeps := nixFilesDeps[nixFile]
		lib := libraries[nixFile]
		tgtName := "direct"
		lib = &nixLibrary{
			Name:      tgtName,
			Files:     fileDeps.DepSets[1].Files,
		}
		libraries[nixFile] = lib
	}

	var res language.GenerateResult
	for _, library := range libraries {
		res.Gen = append(res.Gen, library.ToRule())
	}

	res.Imports = make([]interface{}, len(res.Gen))
	for i, r := range res.Gen {
		res.Imports[i] = r.PrivateAttr(config.GazelleImportsKey)
	}

	return res
}

type nixLibrary struct {
	Name   string
	Files  []string
}

func (cl *nixLibrary) ToRule() *rule.Rule {
	rule := rule.NewRule("export", cl.Name)
	sort.Strings(cl.Files)
	rule.SetAttr("files", cl.Files)
	rule.AddComment("# autogenerated")
	return rule
}

func fixGazelle(c *config.Config, f *rule.File) {
	for _, l := range f.Loads {
		if l.Has("export") {
			l.Remove("export")
			if l.IsEmpty() {
				l.Delete()
			}
		}
	}
	var nixRules []*rule.Rule
	for _, r := range f.Rules {
		if r.Kind() == "export" {
			nixRules = append(nixRules, r)
		}
	}

	for _, r := range nixRules {
		r.Delete()
	}
}

// Fix repairs deprecated usage of language-specific rules in f. This is
// called before the file is indexed. Unless c.ShouldFix is true, fixes
// that delete or rename rules should not be performed.
func (l *nixLang) Fix(c *config.Config, f *rule.File) {
	fixGazelle(c, f)
}

// CheckFlags validates the configuration after command line flags are
// parsed.  This is called once with the root configuration when
// Gazelle starts.  CheckFlags may set default values in flags or make
// implied changes.
func (s *nixLang) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	return nil
}

// Configure modifies the configuration using directives and other
// information extracted from a build file. Configure is called in
// each directory.
//
// c is the configuration for the current directory. It starts out as
// a copy of the configuration for the parent directory.
//
// rel is the slash-separated relative path from the repository root
// to the current directory. It is "" for the root directory itself.
//
// f is the build file for the current directory or nil if there is no
// existing build file.
func (s *nixLang) Configure(c *config.Config, rel string, f *rule.File) {
	var conf *nixConfig
	if raw, ok := c.Exts[nixName]; !ok {
		conf = &nixConfig{}
	} else {
		tmp := *(raw.(*nixConfig))
		conf = &tmp
	}
	c.Exts[nixName] = conf

	// We follow the same pattern as the go language to allow
	// vendoring of nix repositories.
	if path.Base(rel) == "vendor" {
		conf.prefix = ""
		conf.prefixRel = rel
	}

	if f != nil {
		for _, d := range f.Directives {
			switch d.Key {
			case "prefix":
				if err := checkPrefix(d.Value); err != nil {
					log.Print(err)
					return
				}
				conf.prefix = d.Value
				conf.prefixRel = rel
				return
			}
		}
	}
}

// Embeds returns a list of labels of rules that the given rule
// embeds. If a rule is embedded by another importable rule of the
// same language, only the embedding rule will be indexed. The
// embedding rule will inherit the imports of the embedded rule.
func (cl *nixLang) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

type nixConfig struct {
	// prefix is a prefix of an import path, used to generate importpath
	// attributes. Set with -go_prefix or # gazelle:prefix.
	prefix    string
	prefixRel string
}

// checkPrefix checks that a string may be used as a prefix. We forbid local
// (relative) imports and those beginning with "/". We allow the empty string,
// but generated rules must not have an empty importpath.
func checkPrefix(prefix string) error {
	if strings.HasPrefix(prefix, "/") || build.IsLocalImport(prefix) {
		return fmt.Errorf("invalid prefix: %q", prefix)
	}
	return nil
}

// Imports returns a list of ImportSpecs that can be used to import
// the rule r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil
// slice is returned, including an empty slice, the rule will be
// indexed.
func (cl *nixLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	return nil
}

// KnownDirectives returns a list of directive keys that this
// Configurer can interpret. Gazelle prints errors for directives that
// are not recoginized by any Configurer.
func (s *nixLang) KnownDirectives() []string {
	return []string{"prefix"}
}

// RegisterFlags registers command-line flags used by the
// extension. This method is called once with the root configuration
// when Gazelle starts. RegisterFlags may set an initial values in
// Config.Exts. When flags are set, they should modify these values.
func (s *nixLang) RegisterFlags(fs *flag.FlagSet, cmd string, c *config.Config) {
	c.Exts[nixName] = &nixConfig{}
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. A list of imported libraries is typically stored in a
// private attribute of the rule when it's generated (this interface
// doesn't dictate how that is stored or represented). Resolve
// generates a "deps" attribute (or the appropriate language-specific
// equivalent) for each import according to language-specific rules
// and heuristics.
func (cl *nixLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	if importsRaw == nil {
		return
	}
}

type DepSets struct {
	DepSets []DepSet
}

type DepSet struct {
	Kind  string
	Files []string
}

const NIX2BUILD_PATH = "external/nixscan/bin/nixscan"

func nixToDepSets(nixFile string) (*DepSets, error) {
	nixscan, err := bazel.Runfile(NIX2BUILD_PATH)
	cmd := exec.Command(nixscan, nixFile)
	cmd.Dir = os.Getenv("BUILD_WORKSPACE_DIRECTORY")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("%s", out)
		log.Fatal(err)
	}
	var depSets DepSets
	err = json.Unmarshal(out, &depSets)
	if err != nil {
		log.Printf("Incorrect json: %s\n", out)
		log.Fatal(err)
                return nil, err
	}
	//fmt.Printf("%+v\n", depSets)
	return &depSets, nil
}

